<?php

use Drupal\Core\Block\BlockPluginInterface;
use Drupal\taxonomy\Entity\Term;
use Drupal\Core\Url;
use Drupal\Core\Link;
use Drupal\node\NodeInterface;
use Drupal\taxonomy\TermInterface;


/**
 * @file:
 *   Contains the module file for the inline_entity_form_preview module.
 */

/**
 * Implements hook_help().
 */
function inline_entity_form_preview_help($route_name, \Drupal\Core\Routing\RouteMatchInterface $route_match) {
  switch ($route_name) {
    // Main module help for the inline_entity_form_preview module.
    case 'help.page.inline_entity_form_preview':
      $output = '';
      $output .= '<h3>' . t('About') . '</h3>';
      $output .= '<p>' . t('Provides a preview column to display referenced entities directly.') . '</p>';
      return $output;

    default:
  }
}

/**
 * Implements hook_page_attachments().
 *
 * Attach the body-class-from-url library on every page so JS can add a
 * page-derived class to the document body.
 */
function inline_entity_form_preview_page_attachments(array &$attachments) {
  $attachments['#attached']['library'][] = 'inline_entity_form_preview/body_class_from_url';
}



/**
 * Implements hook_block_view_alter().
 */
function inline_entity_form_preview_block_view_alter(array &$build, BlockPluginInterface $block) {

  // Target ONLY your Views block.
  if ($block->getPluginId() !== 'views_block:latest_article_sidebar-block_1') {
    return;
  }

  // Get taxonomy term from route.
  $term = \Drupal::routeMatch()->getParameter('taxonomy_term');
  if (!$term instanceof Term) {
    return;
  }

  /* ================= TITLE (UNCHANGED) ================= */

  $build['#configuration']['label'] = t('Senaste @term', [
    '@term' => $term->label(),
  ]);
  $build['#configuration']['label_display'] = TRUE;

  /* ================= READ MORE BUTTON ================= 

  $avdelning_map = [
    'Löpningen' => 539,
    'Träningen' => 540,
  ];

  $term_label = $term->label();

  if (!isset($avdelning_map[$term_label])) {
    return;
  }

  $url = Url::fromUri('internal:/nyheterna', [
    'query' => [
      'avdelning' => $avdelning_map[$term_label],
    ],
  ]);

  $link = Link::fromTextAndUrl(t('Read more'), $url)->toRenderable();
  $link['#attributes'] = [
    'class' => ['btn', 'btn-primary', 'mt-3'],
  ];

  

  if (isset($build['content']['view_build'])) {
    $build['content']['view_build']['#suffix'] =
      ($build['content']['view_build']['#suffix'] ?? '') . render($link);
  }
  elseif (isset($build['content'])) {
    // Fallback
    $build['content']['#suffix'] =
      ($build['content']['#suffix'] ?? '') . render($link);
  }
\Drupal::logger('debug')->notice($block->getPluginId());

 */
  $build['#cache']['contexts'][] = 'route';
  $build['#cache']['tags'] = array_merge(
    $build['#cache']['tags'] ?? [],
    $term->getCacheTags()
  );
}


/**
 * Implements hook_pathauto_pattern_alter().
 */  

function inline_entity_form_preview_pathauto_pattern_alter(&$pattern, array $context) {
  // Add logging to help debug when and why this hook runs.
  $logger = \Drupal::logger('inline_entity_form_preview');
  $logger->debug('pathauto_pattern_alter called: module=@module, type=@type', [
    '@module' => $context['module'] ?? 'NULL',
    '@type' => $context['type'] ?? 'NULL',
  ]);

  // Be defensive: ensure expected context keys exist and are of the expected
  // types before accessing them. Pathauto can call this hook for different
  // entities, so 'type' may not always be present.
  if (empty($context['module']) || $context['module'] !== 'node') {
    $logger->debug('Skipping pathauto alter: module not node (@module)', ['@module' => $context['module'] ?? 'NULL']);
    return;
  }

  if (empty($context['type']) || $context['type'] == 'article') {
    $logger->debug('Skipping pathauto alter: type not article (@type)', ['@type' => $context['type'] ?? 'NULL']);
    return;
  }

  if (empty($context['data']['node']) || !($context['data']['node'] instanceof \Drupal\node\NodeInterface)) {
    $logger->debug('Skipping pathauto alter: node missing or invalid');
    return;
  }

  $node = $context['data']['node'];
  $logger->debug('Processing node @nid (@title)', ['@nid' => $node->id(), '@title' => $node->label()]);
  $new_pattern = '';

  // Check field_section (assuming single-value reference field).
  if ($node->hasField('field_section') && !$node->get('field_section')->isEmpty()) {
    $section = $node->get('field_section')->entity;
    if ($section && $section->hasField('name')) {
      $new_pattern .= $section->get('name')->value . '/';
    }
  }
  else {
    $new_pattern .= 'nyheter/';
  }

  // Check field_theme (assuming single-value reference field).
  if ($node->hasField('field_theme') && !$node->get('field_theme')->isEmpty()) {
    $theme = $node->get('field_theme')->entity;
    if ($theme && $theme->hasField('name')) {
      $new_pattern .= $theme->get('name')->value . '/';
    }
  }

  if (!empty($new_pattern)) {
    $pattern = $new_pattern . '[node:title]';
    $logger->notice('Setting pathauto pattern for node @nid to: @pattern', [
      '@nid' => $node->id(),
      '@pattern' => $pattern,
    ]);
  }
}

/**
 * Implements hook_views_pre_view().
 */
// function inline_entity_form_preview_views_pre_view(&$view, &$display_id, array &$args) {
//   // Target only your view.
//   // if ($view->id() !== 'latest_article_sidebar') {
//   //   return;
//   // }
 
// }



  